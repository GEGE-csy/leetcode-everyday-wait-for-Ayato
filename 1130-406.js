// 假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。
// 每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。
// 请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，
// 其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

// 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
// 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
// 解释：
// 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
// 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
// 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
// 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
// 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
// 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
// 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
/**
 * @param {number[][]} people
 * @return {number[][]}
 */
// 排序应该选一个标准排，如果按k来排，k和h的序列都不满足要求
// 选择按身高排，身高高的排在前面（一样高的话k小的在前面）
// 因为要遍历数组并对其进行插入操作，应该先插身高高的，如果先插矮的，高的后面插进来又要重新改矮的顺序
// （其实就是高的会影响矮的，矮的不会影响高的）
// 插入时按照k来当index插入即可
// [ [ 7, 0 ], [ 7, 1 ], [ 6, 1 ], [ 5, 0 ], [ 5, 2 ], [ 4, 4 ] ]
 var reconstructQueue = function(people) {
  people.sort((a,b) => {
    if(a[0] === b[0]) {
      return a[1]-b[1]
    } else {
      return b[0]-a[0]
    }
  })
  let queue = []
  for(let i = 0; i < people.length; i++) {
    let right = people[i][1]
    queue.splice(right, 0, people[i])
  }
  return queue;
};